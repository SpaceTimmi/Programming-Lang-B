#lang racket

(provide (all-defined-out)) ;; so we can put tests in a second file

;; put your code below


;; Question 1
(define (sequence low high stride)
  (cond [(or (> low high) (< stride 0)) null]
        [(= (+ low stride) high) high]
        [#t (cons low (sequence 
                       (+ low stride) 
                       high 
                       stride))]))

(sequence 3 11 2) ; `(3 5 7 9 11)
(sequence 3 8 3)  ; `(3 6)
(sequence 3 2 1)  ; `()

;; Question 2
(define (string-append-map xs suffix)
  (map
   (lambda (s) (string-append s suffix))
   xs))

(string-append-map (list "market" "paint" "list") "ing")


;; Question 3

(define (list-nth-mod xs n)
  (letrec ([ith (remainder (length xs) n)]
           [get-ith (lambda (ys acc) (if (= acc ith) (car ys) (get-ith (cdr ys) (+ acc 1))))])
    (cond [(negative? n)(error "list-nth-mod: negative number")]
          [(null? xs)(error "list-nth-mode: empty-list")]
          [#t (get-ith xs 0)])))

(list-nth-mod (list 1 2 3 4 5 6 7) 4) ;4


;; Question 4
(define (stream-for-n-steps s0 n)
  (letrec ([recurs (lambda (s acc)
                     (cond [(= acc n) null]
                           [#t (let ([res ((cdr s))])
                                 (cons (car s) (recurs res (+ acc 1))))]))])
    (recurs s0 0)))







